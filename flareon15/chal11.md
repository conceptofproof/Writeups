#Challenge 11
####Binary: CryptoGraph
####Type: PE Executable
####Arch: x86

##Josh's Solution
This level was by far the most difficult in the challenge. At least, for me. After a combined total of ~30 hrs of painful reversing, however, I finally solved it. I lost a lot of time trying to understand everything the encryption did which turned out to be a trap.
<br><img src="imgs/trap.png" width="300"><br>
Fortunately, to solve this challenge you don't really need to understand what everything does. You just need gist of how the program works and how what functions you do understand interact with each other. Half of reversing is just learning to block out the white noise and focusing on what's important: what happens to the data you can control.
 
When I executed the program without any arguments, the program sent back a message, "The number of parameters passed in is incorrect." Looking closer at the program I noted that it uses CreateFile() to create a file called "secret.jpg" and return a handle that can be used to access that file. The program also takes in 1 command line argument and if it is an integer, returns its hex equivalent which is subsequently passed into the function at address 0x401910.



 
I also noticed after running several trials with different numbers as the command line argument, that the program always seems to hang and never naturally terminates. When terminating the program prematurely, it always outputs an empty secret.jpg file. My guess then, was that I had to enter the correct input which would produce a valid .jpg file, hopefully, containing the solution.
First, I had to figure out what was causing the program to hang. Looking at the disassembly again in IDA, I traced  the problem to function 0x401170 which enters a really long loop. Its jnz exit condition uses an outrageous number like 0x2A133064, or 705,900,644 which is slowly decremented bit by bit. Yeah, I wasn't going to wait for that loop to finish. Especially not since I was running the program on a really crappy Windows VM. So I had to try a different approach.
After playing around with argv[1] for a bit, I noticed that different inputs affected the value the aforementioned jnz exit condition references. So instead of having to iterate through the loop 0x2A133064 times, I would have to iterate through it 0xC53A3550 times! Wow, amazing! Not.  
Tired and confused, I decided to take a step back and see exactly how argv[1] was affecting that exit condition value by following it. After all, at that point in the level, it was the only element of the program that I knew I could control. While setting an initial hardware r/w bp on argv[1] and following the addresses where it is read or copied from, and setting bp's on those addresses and so on and so forth, I noticed only the lower byte of the hex number ever gets used. This observation implies something comforting: that one of the decimal numbers between 0 and 255 has to be correct and allow me to get through the loop without hanging.
256 numbers is easily brute-forceable so I whipped up a quick IDAPython script to find the correct value:

After grabbing a refreshingly bitter cold brew and getting a couple minutes of fresh air, I came back to the script which had finished and spit out the decimal number 205. When 205 is used as argv[1] the loop only has to decrement from 0xffff or 65535, which, even on my slow ass VM, is instantaneous. 
However, after I exited this loop, I came across another obstacle. The function this loop is contained within is called in another loop at the end of function 0x4015D0 which depends on an exit condition which increments a value until it hits 0x20, or 32. And with each iteration, the value the exit condition references in the previous loop, 0xffff, increases substantially. It wasn't feasible, at least on my Windows VM, to wait for the entire loop to finish. Therefore, I was left with only two options: 1) lavishly spend an inordinate amount of money on a super computer 2) find a shortcut. I decided to go with 2). 
After browsing twitter for a bit and reading some of the hints given by [***] during their #askflare session, I deduced that I could binary patch this loop to end it prematurely and still get a valid jpg file. I just had to figure out the exact number of times to let the loop run before exiting it. 
To do this, I first observed that the number of times the loop runs affects the value of a variable in function 0x401B60 upon which, several arithmetic calculations are performed to determine the flow of execution in this function. This function appears to decrypt the data that is later written to the .jpg but only does so properly if the function call at address 0x401C45 which executes the function @ 0x401B20 can be reached. In order to do this I had to find the correct number of times to iterate through the loop in order to produce a variable which would allow the flow of execution to reach 0x401C45.
After following the disassembly, and getting confused by Hex-Rays, I was able to reduce the problem of finding the variable, x, to the following: given a number x s.t. 0x0 < x < 0x7fffffff, the result of right shifting x by 0x18 != 0, and the result of right shifting x by 0x1a == 0. So now we have several constraints to play with, and what better way to find a number that satisfies these constraints than with our favorite SMT solver, Z3?

After running this script, Z3 tells us that the constraints can all be satisfied by the decimal number 33554432, or 0x2000000. So putting everything together, we now need to find the number of iterations of the loop in function 0x4015D0 to allow that will set the variable in function 0x401B60 to the value 0x2000000. After playing around with this for a little bit and noticing a pattern, I quickly figured out that I needed to let the loop run until it hit 0x0B. So, I binary patched the loop condition to reflect this by changing the 0x20 to 0x0B and let the program run to completion after passing it an exception. Finally when I checked my file directory after doing this, I found a valid secret.jpg waiting for me. 
